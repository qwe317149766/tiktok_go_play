# Linux 环境示例（复制为 .env.linux 或 env.linux 后填写真实配置）

# 配置文件版本号：用于和 requirements.txt 同步（当前 curl_cffi 版本）
CURL_CFFI_VERSION=0.14.0

# 生成器开关
SAVE_TO_REDIS=1
SAVE_TO_FILE=1

# mwzzzh_spider 任务数：
# 默认直接复用 MAX_GENERATE（只改一个配置即可同时控制生成数量/任务数量）。
# 如需单独覆盖，再手动加一行：MWZZZH_TASKS=100

# 最多生成设备数量（上限 100000）
MAX_GENERATE=100000

# mwzzzh_spider.py（轮询补齐模式：Linux 默认开启；Windows 可通过 MWZZZH_POLL_MODE=1 调试）
# - 轮询补齐：检查 Redis 设备池数量，缺多少就自动注册补齐多少
# MWZZZH_POLL_MODE=1
# MWZZZH_POLL_INTERVAL_SEC=10
# 设备池最终数量：统一使用 REDIS_MAX_DEVICES（不要再配置 REDIS_TARGET_DEVICES，已废弃）
# 单轮补齐最大注册数量（避免一次补太多）
# MWZZZH_POLL_BATCH_MAX=2000

# mwzzzh_spider.py keep-alive（Session 复用 + 达到最大次数自动淘汰重建）
# - 默认开启（MWZZZH_KEEPALIVE=1）
# - 每个 Session 处理到 MWZZZH_SESSION_MAX_REQUESTS 次“任务”就会自动淘汰重建
# MWZZZH_KEEPALIVE=1
# MWZZZH_SESSION_POOL_SIZE=200
# MWZZZH_SESSION_MAX_REQUESTS=200
# MWZZZH_IMPERSONATE=chrome131_android

# 生成并发数（线程）
# 统一并发主开关：
# - generate_devices_bulk.py：控制设备生成并发
# - mwzzzh_spider.py：控制网络并发（MAX_CONCURRENCY）
# - goPlay/demos/stats/dgmain3：如果不设置 STATS_CONCURRENCY，会回退使用 GEN_CONCURRENCY
GEN_CONCURRENCY=200
# stats 项目并发（可选；优先级高于 GEN_CONCURRENCY）
# STATS_CONCURRENCY=200

# stats 设备连续失败阈值（用于“方式A：坏设备自动补位”）
# - 网络错误不会计入连续失败
# - 优先级：STATS_DEVICE_FAIL_THRESHOLD > DEVICE_FAIL_THRESHOLD > 默认 10
# STATS_DEVICE_FAIL_THRESHOLD=10

# stats cookies 连续失败阈值（达到后自动更换 cookies；网络错误不计入连续失败）
# - 仅 Redis 模式（COOKIES_SOURCE=redis）生效
# - 优先级：STATS_COOKIE_FAIL_THRESHOLD > COOKIE_FAIL_THRESHOLD > 默认 10
# STATS_COOKIE_FAIL_THRESHOLD=10

# stats 设备成功播放上限（达到后淘汰并补位；0=不启用）
# - 优先级：STATS_DEVICE_PLAY_MAX > DEVICE_PLAY_MAX > 默认 0
# STATS_DEVICE_PLAY_MAX=0
# stats 设备创建时间筛选：只使用 create_time 早于当前时间 N 小时的设备（适用于 file/redis）
# - 0=不筛选
# STATS_DEVICE_MIN_AGE_HOURS=0

# stats（Windows/非抢单模式）播放目标视频（视频ID，Linux 抢单模式会忽略它）
# AWEME_ID=7569635953183100191

# stats（抢单模式）开关：默认 Linux=1，Windows=0
# 本地/Windows 想模拟抢单测试：把 STATS_ORDER_MODE 改成 1，并配置好 DB_* 指向 orders 表
# STATS_ORDER_MODE=1
# 抢单模式 DB flush 间隔（秒）：每隔 N 秒把本轮新增 delivered 回写 MySQL，降低意外退出损失
# STATS_ORDER_DB_FLUSH_SEC=5
# 抢单模式：允许重新抢 In progress 订单的“超时秒数”（进程崩溃/卡死恢复）
# STATS_ORDER_STALE_SEC=120
# 抢单模式：轮询抢单间隔（毫秒）
# STATS_ORDER_POLL_MS=500

# 抢单模式：订单进度实时写 Redis 的 key 前缀
# - 实际 key：{prefix}:{order_id}（HASH：delivered/total/updated_at）
REDIS_ORDER_PROGRESS_PREFIX=tiktok:order_progress

# mwzzzh_spider 解析线程池大小（可选；不填则默认按 CPU 核心数自动推导：cores*2，范围 4~64）
# GEN_THREAD_POOL_SIZE=16

# 备份文件：每个文件最多条数（固定平均分到 10 个文件）
PER_FILE_MAX=10000

# mwzzzh_spider.py 写文件刷盘策略：
# - 默认只 flush（性能更好）
# - MWZZZH_FILE_FSYNC=1：每批写入后执行 fsync（更慢，但异常退出时更不容易丢）
# MWZZZH_FILE_FSYNC=0

# Redis 配置（二选一：REDIS_URL 或 host/port/db）
# REDIS_URL=redis://:password@127.0.0.1:6379/0
REDIS_HOST=127.0.0.1
REDIS_PORT=6379
REDIS_DB=0
REDIS_USERNAME=
REDIS_PASSWORD=
REDIS_SSL=0

# Redis 设备池 key 前缀 & 设备 id 字段
REDIS_DEVICE_POOL_KEY=tiktok:device_pool
REDIS_DEVICE_ID_FIELD=cdid

# signup（dgemail）设备创建时间筛选：只使用 create_time 早于当前时间 N 小时的设备（适用于 file/redis）
# - 0=不筛选
# SIGNUP_DEVICE_MIN_AGE_HOURS=0

# Redis 最大保存设备数量（达到后按 use_count 最大淘汰）
REDIS_MAX_DEVICES=100000
# Redis 淘汰策略（默认 play：按播放次数最大淘汰；可选 use/attempt）
# REDIS_EVICT_POLICY=play

# startUp 注册 cookies 池（Go signup 写入、Go stats 读取）
REDIS_STARTUP_COOKIE_POOL_KEY=tiktok:startup_cookie_pool
# cookies 池最大数量（导入/写入时生效；超过后可在后台选择 evict 或返回剩余）
# REDIS_MAX_COOKIES=0

# dgemail（signup）轮询补齐 cookies：Linux 默认开启；Windows 可用 DGEMAIL_POLL_MODE=1 模拟调试
# - 轮询补齐：检查 Redis cookies 池数量，缺多少就自动注册补齐多少
# DGEMAIL_POLL_MODE=1
# DGEMAIL_POLL_INTERVAL_SEC=10
# 目标 cookies 池大小（优先级：REDIS_TARGET_COOKIES > REDIS_MAX_COOKIES > STARTUP_REGISTER_COUNT > MAX_GENERATE）
# REDIS_TARGET_COOKIES=100000
# 单轮补齐最大注册数量（避免一次补太多）
# DGEMAIL_POLL_BATCH_MAX=2000
# dgemail 注册并发（默认 50）
# SIGNUP_CONCURRENCY=50
# startUp 注册次数（用于生成/收集 cookies 的目标数）
STARTUP_REGISTER_COUNT=100000
# signup 成功后是否把 cookies 写入 Redis（供 stats 使用）
SAVE_STARTUP_COOKIES_TO_REDIS=1
# stats 读取 cookies（推荐只用 COOKIES_SOURCE 控制，其他地方一致）
# - 推荐写法：COOKIES_SOURCE=redis
# - 兼容旧写法：COOKIES_FROM_REDIS=1（不推荐，仅兼容）
COOKIES_SOURCE=redis
# COOKIES_LIMIT=100000

# 设备来源（Go signup / Go stats 读取设备的开关，推荐只用 DEVICES_SOURCE，其他地方一致）
# - 支持的取值：
#   - DEVICES_SOURCE=redis  ：从 Redis 设备池读取（Python 注册成功写入的设备池）
#   - DEVICES_SOURCE=file   ：从本地文件读取（signup 默认：goPlay/demos/signup/dgemail/data/devices.txt；stats 默认：goPlay/demos/stats/dgmain3/devices.txt）
#   - DEVICES_SOURCE=（不填/其它任意值） ：等价于 file
# - 兼容旧写法：DEVICES_FROM_REDIS=1（不推荐，仅兼容；会覆盖 DEVICES_SOURCE）
# - DEVICES_LIMIT：从 Redis 读取时的最大设备数量（0 表示不限制；默认会回退 MAX_GENERATE）
DEVICES_SOURCE=redis
# DEVICES_FROM_REDIS=0
# DEVICES_LIMIT=100000

# 数据库配置（后续 Go 项目读取使用；本脚本暂不使用）
DB_HOST=
DB_PORT=
DB_USER=
DB_PASSWORD=
DB_NAME=

# Go API Server（api_server）
API_ADDR=:8080
# API_KEY 从数据库 api_keys 表读取，不再使用 env 配置

# API Admin（新增/追加 api_key + 额度的页面）
# 填“管理员明文密码的 MD5(hex小写)”，后端会用 MD5(你输入的密码) 做校验
# 示例：echo -n 123456 | md5sum
ADMIN_PASSWORD_MD5=

# API KEY Redis 永久缓存（api_server 使用）
REDIS_API_KEYS_KEY=tiktok:api_keys


